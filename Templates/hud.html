<!DOCTYPE html>
<html>
<head>
    <title>DCS HUD</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Changa:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        html, body { margin: 0; padding: 0; overflow: hidden; background: transparent; height: 100%; width: 100%; }
        canvas { display: block; }
    </style>
</head>
<body>
<canvas id="hudCanvas"></canvas>

<script src="/static/js/utils.js"></script>

<script>
    const socket = io();
    const canvas = document.getElementById('hudCanvas');
    const ctx = canvas.getContext('2d');

    // --- SYSTEM STATE ---
    let activeProfileName = 'su25t'; 
    let loadedProfiles = {}; 
    
    // --- SHARED DATA OBJECT ---
    window.HUD = {
        telemetry: { 
            lat: 0, lon: 0, alt_sl: 0, 
            alt_baro: 0, alt_r: 0, 
            hdg: 0, pitch: 0, roll: 0, 
            spd: 0, ias: 0, vvi: 0, aoa: 0,
            mode: 0
        },
        interaction: {
            active: false,
            x: 0, 
            y: 0,
            label: "",
            startTime: 0 
        }, 
        camera: null, 
        nav: { 
            hasRoute: false, 
            lat: 0, lon: 0, alt: 0, 
            dist: 0, turn: 0, wpName: "WPT", type: 'wp',
            req_bank: 0, req_pitch: 0,
            apStatus: false
        },
        physics: { accel: 0, vsi: 0 },
        settings: { color: '#33ff33', opacity: 1.0, scale: 1.0, offsetY: 0, showDirector: true, fov: 80 }
    };

    let lastTime = Date.now();
    let lastSpd = 0; let lastAlt = 0;

    // --- SOCKET HANDLERS ---
    socket.on('connect', () => { console.log("Connected to Server"); });

    socket.on('telemetry', (data) => {
        const now = Date.now();
        const dt = (now - lastTime) / 1000;
        
        // Physics Smoothing
        if (dt > 0.1) {
            const spdDiff = (data.spd || 0) - lastSpd;
            HUD.physics.accel = (HUD.physics.accel * 0.8) + ((spdDiff / dt) * 0.2); 
            const altDiff = (data.alt || 0) - lastAlt;
            HUD.physics.vsi = (HUD.physics.vsi * 0.8) + ((altDiff / dt) * 0.2);
            lastSpd = data.spd || 0; lastAlt = data.alt || 0; lastTime = now;
        }

        // 1. POSITION & CAMERA
        HUD.telemetry.lat = parseFloat(data.lat) || 0;
        HUD.telemetry.lon = parseFloat(data.lon) || 0;
        HUD.telemetry.alt_sl = parseFloat(data.alt_sl) || 0;
        if (data.cam) HUD.camera = data.cam;

        // 2. STANDARD TELEMETRY
        HUD.telemetry.hdg = parseFloat(data.hdg) || 0;
        HUD.telemetry.pitch = parseFloat(data.pitch) || 0;
        HUD.telemetry.roll = parseFloat(data.roll) || 0;
        HUD.telemetry.spd = parseFloat(data.spd) || 0;
        HUD.telemetry.ias = parseFloat(data.ias) || 0; 
        HUD.telemetry.vvi = parseFloat(data.vvi) || 0; 
        HUD.telemetry.aoa = parseFloat(data.aoa) || 0;
        HUD.telemetry.mode = parseInt(data.mode) || 0;
        HUD.telemetry.alt_baro = parseFloat(data.alt_baro) || HUD.telemetry.alt_sl;
        HUD.telemetry.alt_r = parseFloat(data.alt_r) || 0;

        const prevAp = HUD.nav.apStatus;
        // 3. NAV DATA
        if (data.steer) {
            HUD.nav.hasRoute = true;
            HUD.nav.lat = parseFloat(data.steer.lat) || 0;
            HUD.nav.lon = parseFloat(data.steer.lon) || 0;
            HUD.nav.alt = parseFloat(data.steer.alt) || 0;
            HUD.nav.turn = parseFloat(data.steer.turn) || 0;
            HUD.nav.dist = parseFloat(data.steer.dist) || 0;         
            HUD.nav.index = parseInt(data.steer.index) || 0;            
            HUD.nav.wpName = data.steer.name ? String(data.steer.name) : `WP ${HUD.nav.index + 1}`;
            HUD.nav.type = data.steer.type || 'wp';         
            HUD.nav.fd_bank = parseFloat(data.steer.fd_bank) || 0;
            HUD.nav.fd_pitch = parseFloat(data.steer.fd_pitch) || 0;     
            HUD.nav.req_bank = parseFloat(data.steer.req_bank) || 0;
            HUD.nav.req_pitch = parseFloat(data.steer.req_pitch) || 0;
            HUD.nav.apStatus = data.steer.ap_status || false;
        } else { 
            HUD.nav.hasRoute = false;
            HUD.nav.apStatus = false;
        }
        if (prevAp && !HUD.nav.apStatus) {
            HUD.nav.apDisconnectTime = Date.now();
        }        
    });

    socket.on('apply_settings', (data) => {
        if (data.theme && data.theme !== activeProfileName) loadProfile(data.theme);
        if (data.color) HUD.settings.color = data.color;
        if (data.brightness !== undefined) HUD.settings.opacity = parseFloat(data.brightness);
        if (data.scale !== undefined) HUD.settings.scale = parseFloat(data.scale) / 100;
        if (data.offset_y !== undefined) HUD.settings.offsetY = parseInt(data.offset_y);
        if (data.showDirector !== undefined) HUD.settings.showDirector = data.showDirector;
        if (data.fov !== undefined) HUD.settings.fov = parseFloat(data.fov);
        if (data.showWpInfo !== undefined) HUD.settings.showWpInfo = data.showWpInfo; 
        if (data.fov !== undefined) HUD.settings.fov = parseFloat(data.fov);
    });

    socket.on('hover_status', (data) => {
        if (data.active) {
            HUD.interaction.x = data.x;
            HUD.interaction.y = data.y;
            HUD.interaction.label = data.label;
            
            // Start timer only on transition from Inactive -> Active
            if (!HUD.interaction.active) {
                HUD.interaction.active = true;
                HUD.interaction.startTime = Date.now();
            }
        } else {
            HUD.interaction.active = false;
            HUD.interaction.startTime = 0;
        }
    });

    function loadProfile(profileName) {
        activeProfileName = profileName;
        if (!loadedProfiles[profileName]) {
            const script = document.createElement('script');
            script.src = `/static/hud_profiles/${profileName}.js`;
            script.onload = () => { console.log(`Profile ${profileName} loaded.`); };
            document.body.appendChild(script);
        }
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const profile = loadedProfiles[activeProfileName];

        if (profile && typeof profile.draw === 'function') {
            ctx.save();
            ctx.translate(canvas.width / 2, 0 + HUD.settings.offsetY);
            ctx.scale(HUD.settings.scale, HUD.settings.scale);
            ctx.globalAlpha = HUD.settings.opacity;
            try {
                profile.draw(ctx, HUD, canvas.width, canvas.height);
            } catch (e) {
                console.error("Draw Error:", e);
            }
            ctx.restore(); // BACK TO SCREEN COORDINATES

            // --- DRAW INTERACTION RING ---
            if (HUD.interaction.active) {
                const ix = HUD.interaction.x;
                const iy = HUD.interaction.y;

                ctx.save();
                
                // 1. Draw Ring (Diameter 4px -> Radius 2px)
                ctx.beginPath();
                ctx.arc(ix, iy, 4, 0, 2 * Math.PI); 
                ctx.lineWidth = 1;
                ctx.strokeStyle = "rgba(0, 255, 0, 0.9)"; // Bright Green
                ctx.stroke();

                // 2. Tooltip Logic (> 2 seconds)
                if (Date.now() - HUD.interaction.startTime > 2000) {
                    const text = HUD.interaction.label || "Switch";
                    
                    ctx.font = "12px sans-serif";
                    const metrics = ctx.measureText(text);
                    const pad = 4;
                    const w = metrics.width + (pad * 2);
                    const h = 16;
                    const tx = ix + 10; // Offset right
                    const ty = iy - 10; // Offset up

                    // Background Box
                    ctx.fillStyle = "rgba(0, 40, 0, 0.8)";
                    ctx.fillRect(tx, ty, w, h);
                    
                    // Green Border
                    ctx.strokeStyle = "#00ff00";
                    ctx.strokeRect(tx, ty, w, h);
                    
                    // Text
                    ctx.fillStyle = "#ffffff";
                    ctx.textBaseline = "middle";
                    ctx.fillText(text, tx + pad, ty + (h/2));
                }
                ctx.restore();
            }
        }
        requestAnimationFrame(draw);
    }

    loadProfile(activeProfileName);
    draw();

    window.registerHudProfile = function(name, methods) { loadedProfiles[name] = methods; };
</script>
</body>
</html>