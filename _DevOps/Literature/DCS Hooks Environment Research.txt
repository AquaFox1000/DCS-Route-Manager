Advanced Telemetry and Event Handling Architectures in DCS World: A Technical Analysis of GameGUI Callbacks and State Synchronization
1. Architectural Paradigms of the DCS Scripting Engine
The internal architecture of Digital Combat Simulator (DCS) World represents a sophisticated, albeit fragmented, ecosystem of Lua environments, each designed to serve distinct functional requirements within the simulation's execution pipeline. Unlike monolithic applications where a single scripting state manages all logic, DCS employs a compartmentalized approach to separate mission logic, hardware export, and server administration. For the developer tasked with integrating external telemetry, managing persistent campaigns, or enforcing server-side rules of engagement, understanding the boundaries and bridges between these environments is not merely an academic exercise but a prerequisite for stability and security.
This fragmentation, while beneficial for modularity and sandboxing, introduces significant complexity in state synchronization. A variable declared in a mission script is invisible to the server administration hook; a function available to the cockpit exporter is inaccessible to the mission trigger system. The GameGUI environment—specifically the server hook system—occupies a unique administrative stratum within this hierarchy. It sits effectively "above" the mission, persisting across mission loads and possessing the capability to orchestrate the server's lifecycle, manage client connections, and, critically, intercept the raw event stream generated by the simulation engine.
1.1 The Tripartite Environment Model
To navigate the GameGUI capabilities effectively, one must first delineate the three primary execution contexts that define the DCS scripting landscape. These environments operate as distinct Lua states, meaning they do not share global variables (_G) or memory space. Communication between them requires explicit marshaling of data, typically via string serialization or specific API bridges.
The Mission Scripting Environment
This is the most familiar environment to mission designers. It is the domain where the Mission Editor (ME) triggers reside and where popular frameworks like MIST (Mission Scripting Tools) and MOOSE (Mission Object Oriented Scripting Environment) operate.
* Scope: Ephemeral. The state is initialized when a mission loads and is completely destroyed when the mission ends or restarts.
* Access: It has privileged access to the coalition, trigger, and timer singletons, allowing for the manipulation of groups, flags, and mission flow.1
* Limitations: For security, the standard Lua io (input/output), os (operating system), and lfs (Lua File System) libraries are heavily sanitized (restricted) to prevent malicious missions from compromising the host server.3 This isolation makes it difficult for mission scripts to persist data to disk or communicate with external databases without "desanitizing" the environment, a practice that introduces security vulnerabilities.
The Export Environment
Located typically in Scripts/Export.lua, this environment is engineered for high-frequency telemetry output. It runs synchronously with the simulation loop, often executing callbacks like LuaExportAfterNextFrame at the native frame rate of the simulation.
* Scope: Persistent across the session but re-initialized with mission changes.
* Access: It utilizes the Lo namespace (e.g., LoGetSelfData, LoGetWorldObjects) to retrieve physics data, sensor states, and world geometry.4
* Limitations: Its primary limitation is visibility. To prevent cheating in competitive multiplayer, server administrators can restrict the data available to this environment via allow_object_export and allow_sensor_export settings in the network configuration.5 If these checks fail, functions return nil, rendering the environment useless for clients in a locked-down server.
The GameGUI (Server Hook) Environment
The focus of this report, the GameGUI environment, operates as a server-side administrative layer. Scripts here are loaded from Saved Games/Scripts/Hooks/ and are capable of surviving the transition between missions.
* Scope: Persistent. These scripts load on game startup and remain active as long as the DCS process is running.
* Access: It creates an interface to the DCS and net singletons, providing control over the server process itself (pausing, unpausing, loading missions) and the network layer (chat interception, slot management, banning).7
* Strategic Value: Because it runs on the host machine with full privileges (access to io and lfs), and because it receives global event notifications via onGameEvent, the GameGUI is the ideal location for complex server logic, persistent campaign state tracking, and external API integration. It acts as the "supervisor" of the simulation.
1.2 Memory Isolation and Cross-Environment Bridging
The isolation of the GameGUI means that it cannot directly read a Lua variable inside the running mission. For instance, if a mission script sets a flag BlueTeamScore = 100, the GameGUI hook cannot simply access BlueTeamScore. To bridge this gap, the API provides the net.dostring_in function.
The net.dostring_in Mechanism This function is the primary conduit for inter-environment communication. It allows the GameGUI script to inject a string of Lua code into another environment (mission, export, or config) for execution.8
* Syntax: string net.dostring_in(string state, string lua_code)
* Execution Flow: When called, the lua_code string is compiled and executed within the target state. The return value of that execution is captured, converted to a string, and returned to the GameGUI caller.
* Serialization Requirement: Because the return type is strictly a string, complex data structures (like a table of unit positions) must be serialized (e.g., to JSON) inside the target environment before being returned, and then deserialized in the GameGUI. Functions like net.lua2json and net.json2lua are provided to facilitate this.7
Segfault Risks and Stability While powerful, net.dostring_in carries stability risks. Recent updates to the DCS engine have introduced stricter handling of return values. Passing non-scalar values or malformed strings can lead to segmentation faults (crashes) of the server process. Furthermore, heavy reliance on this polling mechanism—for example, querying the position of 500 units every second via JSON serialization—can introduce significant CPU overhead and frame stuttering, necessitating a careful, event-driven architecture rather than a polling-based one.9
2. The GameGUI Event System: Mechanics and Taxonomy
The core mechanism for reactive programming within the GameGUI is the onGameEvent callback. Unlike the polling loops common in the Export environment, onGameEvent is an interrupt-driven system where the engine pushes notifications to registered Lua hooks whenever a significant simulation state change occurs.
2.1 The onGameEvent Callback Interface
To subscribe to these notifications, a developer must create a Lua table containing the onGameEvent function and register it using DCS.setUserCallbacks.


Lua




local myHook = {}

function myHook.onGameEvent(eventName, eventData)
   -- Logic to handle the event
end

DCS.setUserCallbacks(myHook)

Callback Signature and Variability
The signature of onGameEvent is deceptively simple. While typically documented as receiving an event name and a data table, the actual arguments passed can vary depending on the internal implementation of the specific event type. For the GameGUI, the eventName is essentially the notification type, which dictates the structure of the subsequent arguments.
The robustness of this system relies on the script's ability to filter and process these events efficiently. Since onGameEvent fires for every single bullet impact (S_EVENT_HIT), every engine startup, and every AI decision, an inefficient handler can degrade server performance. Best practices dictate a rapid filter at the top of the function to discard irrelevant event types before proceeding to complex logic.
2.2 Event Dispatching and Execution Flow
When an event occurs in the C++ engine (e.g., a missile hits a tank), the engine marshals the relevant data into a Lua table and iterates through the list of registered user callbacks.
* Synchronicity: These callbacks are executed synchronously within the main simulation thread. This implies that any blocking operation within an onGameEvent handler (such as a network request waiting for a response) will pause the entire simulation, causing lag for all connected clients.
* Order of Operations: Events are generally dispatched in the order they occur physically, but the specific order in which different registered hooks receive the event is determined by the alphanumeric sorting of the filenames in the Hooks directory.7 This can create subtle dependencies if multiple scripts attempt to modify the same state based on the same event.
3. Lifecycle Event Analysis: Birth, Death, and Persistence
For any system tracking the state of the campaign—such as a persistent warfare server or a kill-logging bot—understanding the lifecycle events of simulation objects is paramount. The DCS engine tracks objects from their instantiation (BIRTH) to their removal (DEAD or LOST). However, the relationship between these events is nuanced, involving race conditions and garbage collection timing that can trap unwary developers.
3.1 Unit Instantiation: S_EVENT_BIRTH
The S_EVENT_BIRTH (Enum ID: 15) is the genesis event for any object in the DCS world. Introduced in version 1.2.4, it signals that an object has been created and initialized within the simulation memory space.11
* Trigger Conditions: This event fires at mission start for all pre-placed units and dynamically whenever a unit is spawned via script or reinforcement logic.
* Payload Structure:
   * id: 15 (The Enum ID for Birth).
   * time: The simulation time of the spawn.
   * initiator: The Lua Object representing the spawned unit.
* The "Shadow State" Imperative: The critical insight regarding S_EVENT_BIRTH is its role in establishing a "Shadow State" or cache. As we will explore in the section on Unit Death, the initiator object passed in death events is frequently stale or functionally dead by the time the Lua script processes it. Accessing properties like getCoalition() or getTypeName() on a dead object often returns nil or causes errors.
   * Implication: A robust script must capture the unit's static data (ID, Name, Type, Coalition, Category) at the moment of S_EVENT_BIRTH and store it in a local Lua table indexed by the Unit Name or ID. This allows the script to look up the unit's details later, during a DEAD event, using only the ID, completely bypassing the need to query the potentially invalidated C++ object.12
3.2 The Physics of Destruction: S_EVENT_DEAD vs S_EVENT_CRASH
The termination of a unit's lifecycle is signaled by S_EVENT_DEAD (Enum ID: 8). While seemingly straightforward, its implementation reveals the complexity of the engine's damage model.13
* S_EVENT_DEAD (8): This fires when an object is "completely destroyed." For ground units, this is when health reaches zero. For aircraft, this can be triggered by catastrophic mid-air damage (explosion) or ground impact.
* S_EVENT_CRASH (5): This event is specific to aircraft impacting the terrain. Crucially, an aircraft can trigger S_EVENT_DEAD mid-air (e.g., pilot killed, wing sheared, fuel explosion) before triggering S_EVENT_CRASH. In such cases, the script may receive a sequence of events: HIT -> DEAD -> CRASH.
* The "Nil Initiator" Race Condition: A recurring issue documented in the research is the invalidation of the initiator object. By the time S_EVENT_DEAD is pushed to the GameGUI, the engine may have already begun the cleanup process for that entity. Scripts attempting to introspect the initiator (e.g., event.initiator:getName()) often fail with runtime errors because the object reference is no longer valid in the Lua state. This reinforces the necessity of the "Shadow State" cache populated at birth.12
3.3 The Logic of Attrition: S_EVENT_UNIT_LOST and S_EVENT_KILL
To address ambiguities in the DEAD and CRASH sequence, specifically for aerial units, DCS introduced S_EVENT_UNIT_LOST (Enum ID: 30) in version 2.5.6.15
* S_EVENT_UNIT_LOST (30): This event represents a logical loss of the unit rather than a purely physical one. For an aircraft spiraling out of control with a dead pilot, UNIT_LOST may fire significantly earlier than the crash. This allows campaign scripts to register the attrition immediately, without waiting for the physics engine to resolve the ground impact, which might be delayed or happen outside the tracking logic's scope.
* S_EVENT_KILL (28): Also added in 2.5.6, this event explicitly links a victim to a killer. Prior to this, developers had to heuristically match S_EVENT_HIT records with S_EVENT_DEAD records to determine credit. S_EVENT_KILL provides a unified payload containing both the initiator (killer), target (victim), and weapon_name, simplifying the logic for kill-boards and scoring systems.11
3.4 Handling Race Conditions and Object Invalidity
The synthesis of these events paints a picture of a system where object validity is transient. The robust handling pattern for unit death involves a hierarchy of checks:
1. Listen for DEAD, UNIT_LOST, and PILOT_DEAD.
2. Extract the Unit Name or ID from the event structure.
3. Retrieve the full unit metadata (Coalition, Type) from the local "Shadow State" cache created at BIRTH.
4. Process the logic using the cached data, ignoring the likely stale initiator object for anything other than identification.
5. Clean Up the cache entry only after a safe delay or upon mission restart to prevent memory leaks.
4. Tactical Map Interaction: Marker Events
The F10 map in DCS is not just a passive display; it is an interactive canvas that supports user-generated drawings and text. The GameGUI exposes these interactions through specific marker events, allowing for dynamic mission control—for example, a commander drawing a circle on the map to designate a "Combat Air Patrol" zone for AI, or marking a target for artillery.
4.1 The Marker Event Suite (ADDED, CHANGE, REMOVE)
The interaction lifecycle is managed by three events: S_EVENT_MARK_ADDED (25), S_EVENT_MARK_CHANGE (26), and S_EVENT_MARK_REMOVE (27).16
* S_EVENT_MARK_ADDED (25): Triggered when a new mark is committed to the map.
   * Payload:
      * idx: A unique numeric identifier for the mark (Mark ID).
      * time: Simulation timestamp.
      * initiator: The player unit creating the mark.
      * coalition: The visibility scope (-1 if public).
      * groupID: The group scope (-1 if public).
      * text: The content of the text box associated with the mark.
      * pos: A vec3 vector {x, y, z} representing the position.
* S_EVENT_MARK_CHANGE (26): Fires when the user edits the text or drags the mark to a new location. This allows scripts to react to updated orders without requiring the user to delete and redraw.
* S_EVENT_MARK_REMOVE (27): Fires when the mark is deleted. Scripts must use this to clean up any logical zones or tasks associated with the mark ID.
4.2 Geometric Constraints and Payload Limitations
A critical finding in the documentation analysis is the geometry limitation of the GameGUI event payload. The F10 map tool allows users to draw complex shapes: lines, circles, and polygons. However, the S_EVENT_MARK_ADDED payload does not natively expose the vertices of a polygon or the radius of a circle in the GameGUI event table.17
* The Limitation: The event table provides a single pos vector. For a polygon, this might be the centroid or the first point clicked. The specific list of vertices defining the shape's perimeter is missing from the standard GameGUI callback data.
* Implication: A script relying solely on onGameEvent cannot natively distinguish between a point marker and a 5-point polygon zone, nor can it know the boundaries of that zone.
* Workarounds: Developers typically circumvent this by parsing the text field. A user might be instructed to write command strings like -zone radius:500 or -poly (requiring multiple individual point markers) to define geometry. Alternatively, sophisticated scripts may use net.dostring_in to query the internal mission state (if accessible) to find the corresponding drawing object in the mission environment's trigger.action tables, though this is complex and not guaranteed to be synchronized in real-time.
4.3 Coordinate Systems and Spatial Reference
The pos vector provided in marker events uses the internal DCS 3D coordinate system (x, y, z), where y represents altitude (often 0 for map markers) and x/z represent the horizontal plane.
* Conversion: To make this data useful for players (who use Lat/Long or MGRS), the script must convert these internal coordinates. Functions like coord.LOtoLL (available in the Mission environment) are often needed. This again requires the GameGUI script to reach into the Mission environment via net.dostring_in to perform coordinate conversion if the GameGUI environment itself lacks the coord singleton (which it typically does).
5. Cross-Environment Interoperability and State Synchronization
The effective operation of a GameGUI script often hinges on its ability to manipulate the Mission environment. This requirement creates a demand for a robust bridge between the two memory states.
5.1 The net.dostring_in Bridge
net.dostring_in is the only official API for executing code across environment boundaries. It acts as a remote procedure call (RPC) mechanism.1
* Mechanism: The function takes the target environment name (e.g., 'mission') and a string of Lua code. It compiles and runs this code in the target's Lua state.
* Data Retrieval: To get data back, the injected string must return a value. Since dostring_in returns strings, complex return types must be serialized.
   * Example: To get a list of all alive units from the mission environment:
Lua
local lua_cmd = "return net.lua2json( coalition.getGroups(2) )" -- 2 = Blue coalition
local json_result = net.dostring_in('mission', lua_cmd)
local groups_table = net.json2lua(json_result)

5.2 Serialization Protocols: JSON and Lua Tables
The reliance on string serialization (JSON) introduces a performance consideration. net.lua2json and net.json2lua are convenient but can be CPU-intensive if applied to large datasets (e.g., serialization of the entire "Order of Battle" every second).7
   * Optimization: Robust scripts minimize the volume of data passed through dostring_in. Instead of fetching the entire unit table, a script should fetch only what changed, or rely on GameGUI events (BIRTH/DEAD) to maintain its own local cache, using dostring_in only for initialization or specific queries that cannot be answered by events.
5.3 Security Sandboxing and Sanitization
A major operational constraint is the sanitization of the Mission environment. By default, io and lfs are disabled in MissionScripting.lua to prevent missions from accessing the server's file system.3
   * GameGUI Privilege: The GameGUI environment, running from Saved Games, typically retains access to these libraries.
   * The Bypass: A GameGUI script can theoretically use dostring_in to inject file I/O capabilities into the Mission environment (e.g., by passing a global function wrapper). However, this bypasses the intended security model and is strictly discouraged for public servers, as it could allow a malicious mission file (downloaded from a client) to execute arbitrary file operations on the server.
6. Telemetry and External Integration Architecture
For applications requiring real-time telemetry (cockpit builders, motion platforms, stats loggers), the GameGUI offers an alternative to the traditional Export.lua.
6.1 The Export Environment within GameGUI
While Export.lua is the standard for client-side telemetry, server-side GameGUI scripts can also access export functions (like LoGetWorldObjects) if the environment is correctly bridged or if the script is running with server privileges.
   * Access Pattern: Export functions in GameGUI must often be prefaced with the Export. namespace (e.g., Export.LoGetModelTime()).
   * Server Settings: The availability of these functions is governed by allow_object_export and allow_ownship_export in network.vault. A robust GameGUI script must gracefully handle cases where these functions return nil due to server security settings.5
6.2 Network Transport Protocols: LuaSocket Implementation
To transmit this data to an external application (like a Discord bot or a SQL database), the script needs a network transport. DCS includes the LuaSocket library, but its use requires strict adherence to non-blocking patterns to avoid freezing the simulation.
Table 1: Networking Protocol Comparison for DCS Hooks
Feature
	TCP Implementation
	UDP Implementation
	Recommendation
	Connection State
	Connection-oriented (Handshake required).
	Connectionless (Fire and Forget).
	UDP for high-freq telemetry. TCP for control/commands.
	Reliability
	High (Guaranteed delivery).
	Low (Packets may drop).
	TCP for chat/admin commands.
	Simulation Impact
	High risk. Blocking on accept or receive freezes the game.
	Low risk. No handshake overhead.
	UDP is safer for beginners.
	Complexity
	High. Requires state management (reconnecting, buffering).
	Low. Simple sendto.
	UDP requires less code.
	6.3 Non-Blocking I/O Patterns and Frame Budgeting
The DCS Lua engine is single-threaded. If a script executes client:receive() on a TCP socket and no data is waiting, the Lua interpreter—and by extension, the entire simulation—halts until the timeout expires. Even a 10ms timeout per frame can devastate the simulation's FPS.
The settimeout(0) Imperative:
To implement a stable TCP server, the socket must be set to non-blocking mode using settimeout(0).
   * Pattern:
   1. Create and bind the server socket.
   2. Set server:settimeout(0).
   3. In the onSimulationFrame callback, call client = server:accept().
   4. If client is returned, handle the connection and set client:settimeout(0).
   5. If nil is returned (timeout), exit the function immediately.
   * Result: This polling pattern checks for network activity instantly and returns control to the simulator if none exists, consuming negligible CPU time.18
7. Operational Best Practices and Design Patterns
7.1 The Shadow State Pattern
To mitigate the issues of object invalidation and the limited payload of GameGUI events, the "Shadow State" pattern is the industry standard for DCS scripting.
   * Concept: The script maintains a local Lua table (the "Shadow State") that mirrors the relevant state of the simulation (Units, Groups, Scores).
   * Mechanism:
   * On S_EVENT_BIRTH, a record is created in the Shadow State: Units[id] = { name =..., coalition =..., type =... }.
   * On S_EVENT_DEAD, the script uses the event's id to retrieve data from Units[id] rather than querying the initiator object.
   * On S_EVENT_UNIT_LOST, the script marks the unit as attritioned in the Shadow State but may retain the data briefly for post-mortem analysis.
   * Benefit: This decouples the script's logic from the volatile C++ memory management of the engine, ensuring crash-free operation even when events fire out of expected order.
7.2 Robust Error Handling and pcall
Given the complexity of the environment, runtime errors are inevitable (e.g., network disconnects, malformed data). A GameGUI script runs in the main thread; an unhandled error can terminate the entire hook script for the session.
   * Pattern: Wrap all "risky" operations (especially network I/O and dostring_in calls) in pcall (protected call).
Lua
local status, err = pcall(function()
   -- Risky network operation
   client:send(data)
end)
if not status then
   log.write("MyHook", log.ERROR, "Network error: ".. tostring(err))
   -- Initiate reconnection logic
end

This ensures that a transient network failure does not crash the entire server administration system.21
Conclusion
The DCS World GameGUI environment is a powerful tool for extending the simulator's capabilities beyond the cockpit. By mastering the onGameEvent callback, developers can tap into the pulse of the simulation, tracking the birth and death of every entity on the battlefield. However, the system demands a defensive programming style. The "Shadow State" pattern is essential to navigate the treacherous waters of object invalidation, while the specific limitations of map marker payloads require creative parsing solutions. Furthermore, the integration of external networking via LuaSocket necessitates a strict adherence to non-blocking I/O patterns to preserve the simulation's integrity. As DCS evolves, the addition of events like UNIT_LOST and RUNWAY_TOUCH points toward a future of even greater granular control, but the fundamental principles of state synchronization and environment isolation discussed in this report will likely remain the cornerstones of advanced DCS development.
Works cited
      1. Difference between Gamegui and mission script - DCS World Forums, accessed on January 15, 2026, https://forum.dcs.world/topic/156576-difference-between-gamegui-and-mission-script/
      2. The Lua Console — DCS-BIOS v0.10.0 documentation, accessed on January 15, 2026, https://dcs-bios.readthedocs.io/en/latest/lua-console.html
      3. Is there a way to get DCS's lua to read/write from/to a file? : r/hoggit - Reddit, accessed on January 15, 2026, https://www.reddit.com/r/hoggit/comments/7b7u79/is_there_a_way_to_get_dcss_lua_to_readwrite/
      4. DCS export - DCS World Wiki - Hoggitworld.com, accessed on January 15, 2026, https://wiki.hoggitworld.com/view/DCS_export
      5. New File Integrity Check - Page 8 - DCS 2.9 - ED Forums, accessed on January 15, 2026, https://forum.dcs.world/topic/138457-new-file-integrity-check/page/8/
      6. DCS-BIOS & Multiplayer · Issue #95 - GitHub, accessed on January 15, 2026, https://github.com/dcs-bios/dcs-bios/issues/95
      7. DCS server gameGUI - DCS World Wiki - Hoggitworld.com, accessed on January 15, 2026, https://wiki.hoggitworld.com/view/DCS_server_gameGUI
      8. DCS func dostring in - Hoggitworld.com - Hoggit Wiki, accessed on January 15, 2026, https://wiki.hoggitworld.com/view/DCS_func_dostring_in
      9. fixed net.dostring_in("mission", "a_do_script(...)") causes SEGFAULT with non-scalar return values - DCS World Forums, accessed on January 15, 2026, https://forum.dcs.world/topic/369715-netdostring_inmission-a_do_script-causes-segfault-with-non-scalar-return-values/
      10. Understanding DCS Server Performance Issues - Fox3 Managed Solutions, accessed on January 15, 2026, https://www.fox3ms.com/post/understanding-dcs-server-performance-issues
      11. DCS event birth - Hoggitworld.com - Hoggit Wiki, accessed on January 15, 2026, https://wiki.hoggitworld.com/view/DCS_event_birth
      12. onEvent bug: event.initiator for unit on death or on leave unit is broken because it's already been destroyed. - DCS World Forums, accessed on January 15, 2026, https://forum.dcs.world/topic/345478-onevent-bug-eventinitiator-for-unit-on-death-or-on-leave-unit-is-broken-because-its-already-been-destroyed/
      13. DCS event dead - Hoggitworld.com - Hoggit Wiki, accessed on January 15, 2026, https://wiki.hoggitworld.com/view/DCS_event_dead
      14. Identical Events not all receiving the same Event data. - DCS World Forums, accessed on January 15, 2026, https://forum.dcs.world/topic/348646-identical-events-not-all-receiving-the-same-event-data/
      15. DCS event unit lost - DCS World Wiki - Hoggitworld.com, accessed on January 15, 2026, https://wiki.hoggitworld.com/view/DCS_event_unit_lost
      16. Anyway to get MarkPanels from GameGUI environment? - Mission Editor - ED Forums, accessed on January 15, 2026, https://forum.dcs.world/topic/299200-anyway-to-get-markpanels-from-gamegui-environment/
      17. DCS event mark added - DCS World Wiki - Hoggitworld.com, accessed on January 15, 2026, https://wiki.hoggitworld.com/view/DCS_event_mark_added
      18. API reference (LuaSocket) - Defold, accessed on January 15, 2026, https://defold.com/ref/beta/socket-lua/
      19. LuaSocket: Introduction to the core, accessed on January 15, 2026, https://w3.impa.br/~diego/software/luasocket/introduction.html
      20. Lua sockets - Asynchronous Events - Stack Overflow, accessed on January 15, 2026, https://stackoverflow.com/questions/12889361/lua-sockets-asynchronous-events
      21. victrox-dev/Apache-DTU: DCS Modification that handles loading of JSON configuration for the AH-64D "Apache" - GitHub, accessed on January 15, 2026, https://github.com/victrox-dev/Apache-DTU
      22. noobs guide to real time telemetry from DCS - Mission Editor - ED Forums, accessed on January 15, 2026, https://forum.dcs.world/topic/132361-noobs-guide-to-real-time-telemetry-from-dcs/